# 2. Ряды
## 2.1 Введение: задачи, приводящие к временным рядам
Не пугайтесь, сейчас не будет интегралов, бесконечных сумм и прочего весёлого из матанализа. Речь пойдёт про временные ряды — это такие данные, которые живут на оси времени, а не в жутких формулах.

### 2.1.1 Задача
Всё началось с того, что наши аналитики захотели видеть разнообразную статистику по клиентам в удобной форме — графики, срезы, агрегаты. Отдельной аналитической БД у нас нет, а продуктовая БД не проходной двор. Решили для этих целей использовать Grafana - инструмент observability, который как раз заточен на агрегацию и отображение данных. Но откуда Grafana должна данные читать и в каком виде их хранить - эти вопросы оставались открытым.

### 2.1.2 Мотивация
Нашим приоритетом было интегрироваться в существующую инфраструктуру. А в ней метрики, которые отображает Grafana, хранятся в VictoriaMetrics - другой инструмент observability, предназначенный для сбора и хранения метрик.

## 2.2 Временные ряды
Для аналитики нужно сразу все и ничего конкретного одновременно. Это значит, что природа собираемых данных, может быть совершенно разной. Например для статистики по пользователям нужны их данные и связи с другими сущностями, а для статистики по клиенту - еще и набор рассчитываемых показателей. При этом VictoriaMetrics тоже собирает разнородные данные, но хранит их в едином формате временных рядов.

Упрощённо, временной ряд — это последовательность значений с меткой времени. Например:
- регистрация кликов пользователей;
- загрузка CPU по времени;
- количество заказов по дням.

Чтобы хранить разные данные во временных рядах, достаточно указать:
- временная метка;
- название статистики;
- значение этой статистики в этот момент времени;
- набор признаков, которые описывают все особенности этой метрики.

Если вы можете выразить какие-либо данные в таком обобщенном формате, то они представимы в виде временного ряда. Такой подход избавляет от необходимости заводить отдельную таблицу под каждую метрику — всё хранится в одной структуре. Существуют специализированные хранилища, оптимизированные для работы с такими структурами данных. Одним из таких хранилищ и является VictoriaMetrics.

## 2.3 TSDB
VictoriaMetrics — наш основной инструмент сбора метрик, уже интегрированный с Grafana, так что на первый взгляд это был идеальный выбор. Подготовили пару вариантов метрик, начали экспериментировать с загрузкой/выгрузкой данных. 
Но первое разочарование не заставило себя ждать: VictoriaMetrics оптимизирована под агрегированные метрики, а не под «сырые» события. Это значит, что после загрузки данных нельзя гарантированно получить их в исходном виде — они могут быть интерполированы, прорежены или агрегированы (особенно на длинных диапазонах). Для нас это было критично — мы хотели иметь возможность вернуться к исходным данным, а не к их сглаженной версии.

Следующим кандидатом стала InfluxDB. Под неё были готовые Ruby-гемы для загрузки и выгрузки данных, и она умеет хранить временные ряды в достаточно гибкой форме. Минус — это отдельная база, которую нужно: администрировать, мониторить, обновлять, бэкапить. Мы не хотели плодить дополнительную инфраструктуру ради одной задачи.

В итоге, вернулись к тому откуда начали. Наша продуктовая БД - это PostgreSQL. Для него есть расширение TimescaleDB, реализующее работу с временными рядами. Этот вариант оказался удачным.
- используем старое решение по хранению данных, при этом не нужно поднимать новый сервис и тащить новые зависимости в код;
- есть возможность достать те же данные, которые положили;
- формат хранения данных в виде временных рядов избавляет нас от необходимости плодить отдельные таблицы для каждой новой метрики и позволяет использовать преимущества, которые обеспечивает расширение TimescaleDB.

## 2.4 TimescaleDB
Какие это преимущества.
В Timescale есть ключевая концепция — Hypertable. Это виртуальная таблица, которая под капотом автоматически делится на чанки (partitioning) по времени и, опционально, по дополнительному ключу.

Что это даёт:
- вставка всегда быстрая, потому что пишем в последний чанк;
- выборка по времени идёт только по нужным чанкам.
- можно автоматически удалять данные старше X дней (retention policies);
- старые чанки можно сжать (Compression);
- автоматический пересчёт агрегированных данных(Continuous aggregates).
И при этом это всё тот же PostgreSQL с SQL, транзакциями и джойнами.
TimescaleDB оснащён набором агрегирующих функций, во многом похожих на Prometheus:
- time_bucket(interval, timestamp) — группировка по временным интервалам (range vector в Prometheus).
- locf (last observation carried forward) — как last_over_time, тянет последнее значение вперёд.
- interpolate — линейная интерполяция пропущенных значений.
- rate, delta — аналоги прометеевских функций для расчёта скорости изменения.
- percentile_agg, approx_percentile — быстрый расчёт перцентилей.

## 2.5 Выводы
TimescaleDB стал для нас универсальным хранилищем статистики и событий. Мы прошли через VictoriaMetrics и InfluxDB, но в итоге выбрали решение, которое:
- не требует новых сервисов;
- безболезненно интегрируется с Rails;
- даёт мощные возможности для работы с временными рядами.

При этом этот подход применим не только для хранения числовых значений, но и вообще любых событий — от логов и действий пользователей до изменений состояния систем. Это делает его универсальным паттерном для многих задач, где важно хранить и анализировать данные во временном разрезе.