# 2. Ряды
## 2.1 Введение: задачи, приводящие к временным рядам
Не пугайтесь, сейчас не будет интегралов, бесконечных сумм и прочего весёлого из матанализа. Речь пойдёт про временные ряды — это такие данные, которые живут на оси времени, а не в жутких формулах.

### 2.1.1 Задача
Всё началось с того, что наши аналитики захотели видеть разнообразную статистику по клиентам в удобной форме — графики, срезы, агрегаты. Отдельной аналитической БД у нас нет, а продуктовая БД не проходной двор. Пришла мысль использовать для этих целей Grafana - инструмент observability, который как раз и заточен на агрегацию и отображение данных. Но откуда Grafana должна данные читать и в каком виде их хранить - эти вопросы пока что оставались открытым.

### 2.1.2 Мотивация
Нашим приоритетом было интегрироваться в существующую инфраструктуру. А в ней метрики, которые отображает Grafana, хранятся в VictoriaMetrics - другой инструмент observability, предназначенный для сбора и хранения метрик.

### 2.1.3 Временные ряды
Естественно для аналитики нужно сразу все и ничего конкретного одновременно - это означает, что природа данных, которые требуются собирать, может быть абсолютно разной. Например для построения статистики по пользователям нужны данные пользователя и его связи с другими сущностями, а для построения статистики по клиенту нужно несколько рассчитываемых показателей. Но если обратиться к кейсу VictoriaMetrics, то мы увидим, что собираемые ей данные тоже абсолютно разнородны, но в хранилище они представлены в едином формате временных рядов.

Упрощенно, временной ряд — это просто последовательность значений с меткой времени. Их много где можно встретить:
- регистрация кликов пользователей;
- загрузка CPU по времени;
- количество заказов по дням.

Как же VictoriaMetrics хранит разнородные данные во временных рядах. Для этого нужно:
- временная метка;
- название статистики;
- значение этой статистики в этот момент времени;
- набор признаков, которые описывают все особенности этой метрики.

Если вы можете выразить какие-либо данные в таком обобщенном формате, то они представимы в виде временного ряда. Это позволит не создавать под каждую метрику отдельную таблицу, а хранить все виды метрик в единой структуре. Существуют специализированные хранилища, оптимизированные для работы с такими структурами данных. Одним из таких хранилищ и является VictoriaMetrics.

### 2.1.4 TSDB
VictoriaMetrics - это наш основной инструмент сбора метрик и уже интегрирован с Grafana, поэтому казалось, что это идеальный выбор. Подготовили пару вариантов метрик, начали экспериментировать с загрузкой/выгрузкой данных. 
И первое разочарование... VictoriaMetrics оптимизирована под агрегированные метрики, а не под "сырые" события. Это значит, что после загрузки данных нельзя гарантированно получить их в исходном виде — они могут быть интерполированы, прорежены или агрегированы (особенно на длинных диапазонах). Для нас это было критично — мы хотели иметь возможность вернуться к исходным данным, а не к их сглаженной версии.

Следующим кандидатом на рассмотрении была InfluxDB. Под неё были готовые Ruby-гемы для загрузки и выгрузки данных, и она умеет хранить временные ряды в достаточно гибкой форме. Минус — это отдельная база, которую нужно: администрировать, мониторить, обновлять, бэкапить. Мы не хотели плодить дополнительную инфраструктуру ради одной задачи.

В итоге, вернулись к тому откуда начали. Наша продуктовая БД - это PostgreSQL. Для него есть расширение TimescaleDB, реализующее работу с временными рядами. Этот вариант оказался удачным.
- используем старое решение по хранению данных, при этом не нужно поднимать новый сервис и тащить новые зависимости в код;
- есть возможность достать те же данные, которые положили;
- формат хранения данных в виде временных рядов избавляет нас от необходимости плодить отдельные таблицы для каждой новой метрики и позволяет использовать преимущества, которые обеспечивает расширение TimescaleDB.

### 2.1.5 TimescaleDB
Что это за преимущества.
В Timescale есть ключевая концепция — Hypertable.
Это виртуальная таблица, которая под капотом автоматически делится на чанки (partitioning) по времени и, опционально, по дополнительному ключу.

Что это даёт:
Вставка всегда быстрая, потому что пишем в последний чанк.
Выборка по времени идёт только по нужным чанкам.
Retention policies — можно автоматически удалять данные старше X дней.
Compression — старые чанки можно сжать и хранить в колоннарном виде.
Continuous aggregates — автоматический пересчёт агрегированных данных.
При этом всё это обычный PostgreSQL — SQL, транзакции, джойны.
TimescaleDB снабжен набором агрегирующих функций, которые во многом похожи на функции Prometheus:
time_bucket(interval, timestamp) — группировка по временным интервалам (range vector в Prometheus).
locf (last observation carried forward) — как last_over_time, тянет последнее значение вперёд.
interpolate — линейная интерполяция пропущенных значений.
rate, delta — аналоги прометеевских функций для расчёта скорости изменения.
percentile_agg, approx_percentile — быстрый расчёт перцентилей.
Timescale явно вдохновлялся TSDB-экосистемой (Prometheus, Influx), чтобы SQL-запросами можно было решать те же задачи, что в PromQL.

Плюсы:
Высокая скорость вставки при больших объёмах.
Оптимизация запросов по времени.
Retention policies и автоматическое сжатие.
Continuous aggregates для ускоренной аналитики.
Полная совместимость с PostgreSQL.
Нет отдельной инфраструктуры.

Минусы:
Выигрыш минимален, если данных мало.
Основная польза, когда фильтр по времени — ключевой.
Continuous aggregates требуют понимания механики.
Сжатые данные сложнее обновлять.

TimescaleDB — это не только для IoT и мониторинга серверов.
Это удобный инструмент, когда у вас:
есть timestamp в каждой записи,
данные растут линейно во времени,
старые данные нужно хранить долго, но не нагружать ими запросы,
часто нужна аналитика по диапазонам времени.
В нашем проекте TimescaleDB стал универсальным хранилищем статистики и событий.
Мы прошли через VictoriaMetrics и InfluxDB, но в итоге выбрали решение, которое:
не добавляет новых сервисов,
интегрируется с Rails без боли,
и при этом даёт мощные возможности для работы с временными рядами.