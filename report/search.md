{слайд 2 - заставка}

# 1. Векторный поиск

## 1.1 Кейсы, в которых недостаточно ILIKE

Когда проект находится на стадии MVP, текстовый поиск зачастую реализуется с помощью самого простого и доступного инструмента — оператора ILIKE. Это разумный выбор, когда нужно быстро добавить базовую возможность поиска без дополнительных сложностей: достаточно просто дописать условие в SQL-запрос — и всё работает. Например:

```sql
SELECT * FROM devices WHERE name ILIKE '%кабель%';
```
Такой подход отлично себя показывает на старте проекта: объём данных невелик, требования к релевантности и полноте результатов ещё не определены, и основная задача — как можно быстрее получить рабочую фичу. Однако по мере роста количества записей и усложнения логики продукта ILIKE начинает демонстрировать свои ограничения — как по производительности, так и по гибкости.

В нашем проекте значительная часть информации о сущностях хранится в jsonb-полях. Это не временное решение и не технический долг — мы сознательно выбрали такой подход, так как данные поступают от внешнего поставщика в формате JSON, причём структура этих данных может быть неустойчивой. Поля могут добавляться, исчезать или менять формат. Подгонять такую структуру под жёсткую реляционную схему означало бы постоянные миграции, риски потери данных и трудности с обратной-совместимостью.

Использование jsonb позволило нам хранить входящие данные «как есть» — и обращаться к нужным полям по мере необходимости. Но когда речь заходит о текстовом поиске по таким полям, удобство быстро сменяется проблемами.

На первом этапе мы использовали простой приём: приводили всё содержимое jsonb к строковому виду и применяли ILIKE.

```sql
SELECT * FROM items WHERE jsonb_data::text ILIKE '%волоконно%';
```

Это действительно работает — поиск возвращает записи, содержащие нужное слово в любом месте JSON-структуры. Но с ростом объёма данных запросы начинают замедляться. PostgreSQL не может использовать индекс при таком приведении — и приходится делать последовательное сканирование (seq scan) всей таблицы. А если таких запросов много, база начинает задыхаться.

Дополнительной сложностью стал пользовательский функционал заметок: клиенты могут прикреплять текстовые комментарии к объектам, и нам нужно было включить их в общий поиск. Так совпало, что к этому моменту объём данных вырос достаточно, чтобы мы начали ощущать реальные задержки в ответах.

Всё это стало сигналом к необходимости переосмыслить архитектуру поиска. Мы начали искать более эффективные способы работы с текстом в PostgreSQL — с поддержкой индексации, релевантности и масштабирования.

## 1.2 Какие есть способы поиска в Postgresql

Когда необходимо реализовать текстовый поиск в PostgreSQL, есть несколько подходов с разной степенью точности, гибкости и производительности.

1. Уже упоминался поиск по шаблону. Поиск по шаблону реализуется оператором LIKE. Такой поиск не учитывает словоформы. Например, если вы ищете "соответствовать", слово "соответствуешь" не будет включено в результат. Этот вид поиска также не ранжирует результаты. Когда найдены тысячи документов, соответствующих критериям поиска, более релевантные документы могут оказаться в конце списка результатов.Кроме того, при использовании шаблонов с префиксами (% в начале строки) PostgreSQL не может использовать индекс, что делает такие запросы медленными на больших объёмах данных.

2. Для полнотекстового поиска в PostgreSQL, может использоваться тип данных `tsvector` . Значение `tsvector` представляет собой отсортированный список уникальных лексем, нормализованных для объединения различных форм одного и того же слова. Под нормализацией понимается выкидывание стоп-слов, таких, как предлоги, обрезание окончаний слов, и так далее. Он работает с операторами для поиска текста с использованием векторов весов.

3. И еще есть модуль `pg_trgm`. Модуль предоставляет набор функций и операторов, которые позволяют работать с трехграммами (триграммами) - это последовательности из трех символов. Это позволяет находить похожие строки, даже если они не совпадают буквенно. Это полезно, например, при исправлении опечаток, поиске синонимов, автодополнении. Трехграммы также учитывают порядок символов и поддерживают операторы для сравнения, что делает их мощным инструментом для полнотекстового поиска.
