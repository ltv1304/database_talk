{ слайд 2 - снипеты с ILIKE }

# 1. Полнотекстовый поиск

## 1.1 Кейсы, в которых недостаточно ILIKE

Когда проект находится на стадии MVP, текстовый поиск зачастую реализуется с помощью самого простого и доступного инструмента — оператора ILIKE. Это разумный выбор, когда нужно быстро добавить базовую возможность поиска без дополнительных сложностей: достаточно просто дописать условие в SQL-запрос — и всё работает. Например:

```sql
SELECT * FROM devices WHERE name ILIKE '%кабель%';
```
Такой подход отлично себя показывает на старте проекта: объём данных невелик, требования к релевантности и полноте результатов ещё не определены, и основная задача — как можно быстрее получить рабочую фичу. Однако по мере роста количества записей и усложнения логики продукта ILIKE начинает демонстрировать свои ограничения — как по производительности, так и по гибкости.

В нашем проекте значительная часть информации о сущностях хранится в jsonb-полях. Это не временное решение и не технический долг — мы сознательно выбрали такой подход, так как данные поступают от внешнего поставщика в формате JSON, причём структура этих данных может быть неустойчивой. Поля могут добавляться, исчезать или менять формат. Подгонять такую структуру под жёсткую реляционную схему означало бы постоянные миграции, риски потери данных и трудности с обратной-совместимостью.

Использование jsonb позволило нам хранить входящие данные «как есть» — и обращаться к нужным полям по мере необходимости. Но когда речь заходит о текстовом поиске по таким полям, удобство быстро сменяется проблемами.

На первом этапе мы использовали простой приём: приводили всё содержимое jsonb к строковому виду и применяли ILIKE.

```sql
SELECT * FROM items WHERE jsonb_data::text ILIKE '%волоконно%';
```

Это действительно работает — поиск возвращает записи, содержащие нужное слово в любом месте JSON-структуры. Но с ростом объёма данных запросы начинают замедляться. PostgreSQL не может использовать индекс при таком приведении — и приходится делать последовательное сканирование (seq scan) всей таблицы. А если таких запросов много, база начинает задыхаться.

Дополнительной сложностью стал пользовательский функционал заметок: клиенты могут прикреплять текстовые комментарии к объектам, и нам нужно было включить их в общий поиск. Так совпало, что к этому моменту объём данных вырос достаточно, чтобы мы начали ощущать реальные задержки в ответах.

Всё это стало сигналом к необходимости переосмыслить архитектуру поиска. Мы начали искать более эффективные способы работы с текстом в PostgreSQL — с поддержкой индексации, релевантности и масштабирования.


{ слайд 3 - варианты поиска }
## 1.2 Какие есть способы поиска в Postgresql

Когда необходимо реализовать текстовый поиск в PostgreSQL, есть несколько подходов с разной степенью точности, гибкости и производительности.

1. Уже упоминался поиск по шаблону. Поиск по шаблону реализуется оператором LIKE. Такой поиск не учитывает словоформы. Например, если вы ищете "соответствовать", слово "соответствуешь" не будет включено в результат. Этот вид поиска также не ранжирует результаты. Когда найдены тысячи документов, соответствующих критериям поиска, более релевантные документы могут оказаться в конце списка результатов.Кроме того, при использовании шаблонов с префиксами (% в начале строки) PostgreSQL не может использовать индекс, что делает такие запросы медленными на больших объёмах данных.

2. Для полнотекстового поиска в PostgreSQL, может использоваться тип данных `tsvector` . Значение `tsvector` представляет собой отсортированный список уникальных лексем, нормализованных для объединения различных форм одного и того же слова. Под нормализацией понимается выкидывание стоп-слов, таких, как предлоги, обрезание окончаний слов, и так далее. Он работает с операторами для поиска текста с использованием векторов весов.

3. И еще есть модуль `pg_trgm`. Модуль предоставляет набор функций и операторов, которые позволяют работать с трехграммами (триграммами) - это последовательности из трех символов. Это позволяет находить похожие строки, даже если они не совпадают буквенно. Это полезно, например, при исправлении опечаток, поиске синонимов, автодополнении. Трехграммы также учитывают порядок символов и поддерживают операторы для сравнения, что делает их мощным инструментом для полнотекстового поиска.


{ слайд 4.1, 4.2 - операторы `tsquery` и снипеты }
## 1.3 Реализация
## 1.3.1 Муки выбора
После экспериментов с ILIKE и приведением jsonb к тексту мы начали искать более надёжные и масштабируемые подходы к полнотекстовому поиску. Рассматривали два варианта: pg_trgm и tsvector.
`pg_trgm` сопоставляет строки по совпадению последовательностей символов (триграмм). Он может находить похожие слова, но не понимает лексический смысл текста. Это скорее поиск "по буквам".
В отличие от него, `tsvector` ориентирован на анализ языка. Он разбивает текст на слова, приводит их к начальной форме, игнорирует служебные слова и позволяет точнее сопоставлять смысл запроса с содержимым. Это уже поиск "по смыслу".
Из этого сравнения выбрали интуитивно более понятный `tsvector`.

## 1.3.2 tsvector
В полнотекстовом поиске PostgreSQL участвуют два ключевых объекта: `tsvector` и `tsquery`.
tsvector — нормализованное представление текста: слова приведены к начальной форме, удалены стоп-слова (здесь имеются ввиду предлоги, а не то что вы подумали), добавлены позиции слов. Оно хранится в базе и может индексироваться.

`tsquery` — поисковый запрос в специальном формате, который умеет оперировать словами, фразами и логическими связками.
Чтобы получить `tsvector` из текста, используется `to_tsvector`.
Чтобы превратить строку в `tsquery`, есть несколько функций:
`plainto_tsquery` — разбивает текст на слова и соединяет их логическим И (&).
`phraseto_tsquery` — ищет слова именно как фразу, сохраняя порядок (<->).
`to_tsquery` — самый гибкий вариант: вы сами пишете tsquery-синтаксис, включая операторы.
В `tsquery` поддерживаются операторы:
& — логическое И (оба слова должны встречаться).
| — логическое ИЛИ (любое из слов).
! — отрицание (слово не должно встречаться).
<-> — поиск слов рядом, в указанном порядке.
<N> — поиск слов на расстоянии N слов друг от друга.


```sql
select to_tsvector('My name is newbie and I''m a database engineer');
```

```sql
select plainto_tsquery('My name is newbie and I''m a database engineer');
```

```sql
select phraseto_tsquery('My name is newbie and I''m a database engineer');
```

`tsvector` можно заиспользовать с ходу. Например так:
```sql
SELECT id FROM wp_fssp.ips WHERE to_tsvector(ip_info::text) @@ plainto_tsquery('russian', 'ЗУБКОВА') and workplace_id=16;
```
Но это наивный подход, потому что:
- не используется индекс для полнотекстового поиска;
- функция `tsvector` вызывается для каждой строки таблицы;

## 1.4 Детали реализации

{ слайд 5 - снипет и может картинка }
### 1.4.1 Формирование корпуса текста для поиска
В большинстве реальных задач данные для поиска находятся в разных полях: фамилия, имя, номер договора и так далее. В нашем случае это было поле с JSON и пользовательские заметоки.
Чтобы поиск работал быстро и эффективно, лучше объединить все эти поля в один дополнительный столбец и хранить в нём всё, что может участвовать в поиске.

Важно помнить что для `tsvector` имеет значение локаль. Она определяет правила нормализации слов, и если она будет выбрана неправильно, поиск может дать неожиданные результаты. Поэтому, чтобы упростить себе жизнь рекомендую сразу приводить строку в дополнительном к нижнему регистру.
И конечно в дополнительный столбец стоит складывать не голый текст, а текст преобразованный в формат `tsvector` 

```sql
to_tsvector('russian', content);
```

{ слайд 6 - +/- индексов }
### 1.4.2 Индексация `tsvector`
Чтобы ускорить полнотекстовый поиск, PostgreSQL предлагает два основных типа индексов:
GIN (Generalized Inverted Index):
- очень быстрый поиск;
- медленнее обновляется;
- оптимален, если тексты меняются редко;

GiST (Generalized Search Tree)
- медленнее ищет;
- быстро обновляется;
- может быть полезен для частых изменений данных;
- для полнотекстового поиска работает как вероятностный метод: результат может содержать «лишние» строки, которые потом фильтруются проверкой условия.

На практике, если данные не меняются каждую секунду, обычно выбирают GIN. GIN индекс устроен как инвертированный индекс:
- в нём хранятся не целые строки, а отдельные элементы (лексемы);
- для каждой лексемы есть упорядоченный список ссылок на строки таблицы;
- это похоже на алфавитный указатель в конце книги — быстро находим слово и сразу переходим к нужным страницам.

{ слайд 7 - снипеты и илюстрация проблем }
### 1.4.3 Префиксный поиск
Если искать по части слова, стандартный @@ без модификаторов не даст результата:

```sql
SELECT to_tsvector('russian', 'иванов александр')  @@ to_tsquery('russian', 'иванов & алекс');
-- False
```
Решает это префиксный поиск с :*:

```sql
SELECT to_tsvector('russian', 'иванов александр') @@ to_tsquery('russian', 'иванов & алекс:*');
-- True
```

В дополнение к вышеупомянутым операторам при работе с типом tsquery существует специальный синтаксис для префиксного поиска — это добавление суффикса :* к слову в запросе. :* означает поиск по префиксу слова — то есть поиск всех слов, которые начинаются с указанного корня или начала. Например, запрос иван:* найдёт слова: "иванов", "иванова", "иваненко" и любые другие слова, начинающиеся с "иван". Без префиксного поиска запрос должен строго совпадать с полной формой слова, и в этом случае поиск становится менее гибким и может не найти нужные результаты. 

Оказалось клиенты иногда не хотят вбивать фамилию или номер договора полностью. Пришлось затянуть префиксный поиск. Но как его использовать? Мы же заранне не знаем какое из слов будет сокращенным. Решение - использовать суффикс рядом с каждым словом. Тут нужно помнить что префиксный поиск не работает в выражениях с позиционными операторами <->.

Это решило проблему неполных слов, но принесло две новые:
- при использовании оператора И (&) релевантных документов меньше, чем хотелось бы;
- при использовании ИЛИ (|) появляется много лишнего шума.

{ слайд 8 - снипет }
### 1.4.4 Ранжирование
Для того чтобы справиться с шумом как правило применяют ранжирование с помощью `ts_rank`.
Это еще одна функция работы с полнотекстовым поиском в PostgreSQL, которая оценивает, насколько хорошо `tsvector` соответствует `tsquery`. В связи со спецификой мы не стали использовать у себя ранжирование результатов. Однако если вам очень надо, то рекомендую дополнительно почитать про индекс `RUM`, который позволяет эффективно использовать ранжирование и сортировку результатов по релевантности прямо на уровне индекса.

{ слайд 9 - снипет, формула }
### 1.4.5 pg_trgm
Еще одним способом уменьшить избыточный шум - это комбинирование `tsvector` и упомятый ранее расширения `pg_trgm`. Это расширение разбивает обе строки — и текст, и запрос — на набор триграмм (подстрок длиной 3 символа, включая пробелы и служебные символы) и считает меру их схожести. Как вы понимаете `pg_trgm` не требует дополнительный синтаксис для префиксного или постфиксного поиска, он просто ищет совпадение триграмм. 

```sql
SELECT show_trgm('example');

+----------------------------------------------------------+
| show_trgm                                                |
|----------------------------------------------------------|
| ['  e', ' ex', 'amp', 'exa', 'le ', 'mpl', 'ple', 'xam'] |
+----------------------------------------------------------+
```
И есть нюанс в в этом коэффициенте. Он называется коэффициент Жаккара и рассчитывается по формуле:

```math
similarity(a,b)=\frac{общее количество уникальных триграмм}{количество общих триграмм}
```
А нюанс в том, что значения similarity не сопоставимы между документами разной длины, если мы ищем короткий фрагмент. Но вот где он особенно хорош - это быстрый поиск похожих строк (нечеткий-поиск (это когда вы в vscode ищите по имени файла), исправление опечаток, поиск по частям слова).

## 1.5 Выводы
PostgreSQL предоставляет мощные и гибкие инструменты для полнотекстового поиска, позволяя адаптировать поиск под самые разные задачи и требования. Однако такая гибкость требует дополнительной настройки и понимания, чтобы добиться оптимального результата. Важно найти баланс: не стоит углубляться в чрезмерно сложные решения, если это приводит к излишним затратам ресурсов и усложнению поддержки. В то же время слишком простой и быстрый поиск может оказаться малоэффективным и неудобным для пользователей. Оптимальный полнотекстовый поиск — это компромисс между скоростью, точностью и удобством настройки.